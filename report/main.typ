#set page(paper: "a4", numbering: "1")

#align(center)[
               #v(24pt)
               #text(size: 1.25em)[= Compiling Linear Sax to WASM]
               #v(16pt)
               CMU CS 15-817: HOT Compilation \
               Mikail Khan
               #v(16pt)
]

#align(center)[== Abstract]

Sax is an intermediate representation (IR) that helps bridge the gap between
high level, richly typed languages and lower level imperative execution.
WebAssembly (WASM) is a bytecode instruction set focused on speed, security, and portability.
It is an appealing compilation target because it can be run quickly and securely
on many platforms, including embedded devices and web browsers, and is used
in industry for accelerating web performance or running untrusted code. In this paper,
I detail the structure and implementation of a Sax to WASM compiler, supporting purely linear
types and 32-bit integers.

#v(8pt)

#set heading(numbering: "1.1")
#show heading.where(level: 2): it => text(size: 0.9em, it)

= Introduction

The most interesting aspect of compiling linear Sax to WASM is memory management.
WASM is lower-level than Sax and exposes details like stack and local layout, so
when starting this project I spent a lot of time and effort trying to optimize these.
However, WASM runtimes often include JIT compilers that make precise stack and local layout
irrelevant to performance. Additionally, `wasm-opt` is a CLI tool and library that runs
many optimization passes, including local allocation. Thus, the main focus of this compiler
is on exploiting linear typing's advantages for memory allocation, with an eye on maintaining
extensibility for adjoint Sax.

The variant of Sax implemented by this compiler is a modified version of the core linear, positive
fragment introduced in Lab 1, with two additions. First, it supports 32-bit signed integers,
leveraging WASM's i32 type. It also supports closures. Both of these types are always unrestricted,
supporting all structural rules. Units are also unrestricted.

The performance of a compiler targeting WASM largely depends on the source language. Manually memory-managed
languages like C or Rust are often only 20-40% slower through WASM, while more dynamic languages like OCaml
or Scala can be 3-8x slower (no sources). Thus, the upper performance bound for linear Sax compiled to WASM 
should be similar to the performance of C compiled to WASM.

== WASM Structure

The structure and interpretation of WASM programs is largely similar to that of well-known 
instruction sets like x86 or Java bytecode, with the major difference that all its control flow is
structured. It is primarily a stack VM; instructions operate on some combination of
bytecode immediates and stack operands. There are no stack manipulation instructions.
Instead, there is a per-function set of local values which can be accessed through static
indices, emulating registers.

WASM also supports both a manually managed heap and a garbage collector.

== WASM Runtimes

There are many different WASM runtimes. The most common are browser engines like Chrome's V8 and Safari's JavaScript Core,
however, there are a variety of WASM runtimes aimed at non-web usage. In particular, I chose a runtime called Wasmtime to evaluate the compiler.

WASM does not specify a system-level interface for I/O on its own. Instead, it supports a robust foreign-function interface,
through which it requires WASM Runtimes to inject I/O functions. There is a proposal for a standardized WASM system interface
called WASI which is gaining support in major runtimes. However, it is not well documented so I opted to embed custom I/O functions
in the runtime. Thus, there is a small amount of code which is not runtime agnostic, for now.

Wasmtime is a popular and well-supported runtime focused on secure embedding. It is built as a JIT compiler on top of the Cranelift 
code generator, which is similar to LLVM but optimized for compilation speed rather than generating optimal code. It already supports
WASI, and can be used through a Rust crate. The WASM files generated by this compiler must be run through a small Rust program which
injects I/O functions and runs Wasmtime.

== Integers

To achieve competetive performance on real programs, I supplement Sax with a native 32-bit integer type.
The only changes to sax are the built-in `int` type and a few built-in metavariables used through Sax's existing
`call` command. The supported builtins are as follows:

- `call _const_{n} dest`: parses the integer out of the metavariable name and writes it to `dest`
- `call _add_ dest l r`: writes `(i32.add l r)` to `dest`
- `call _sub_ dest l r`: writes `(i32.sub l r)` to `dest`
- `call _eqz_ dest n`: writes `(i32.eqz n)` to `dest`
    - In WASM, `(i32.eqz n)` pushes `1` when `n` is zero, and `0` otherwise.
    - I did not add a builtin boolean type to Sax. Instead, this just pushes
      a sum tag with a unit injection. It makes the most sense when used with
      a type like `+{ 'false : 1, 'true : 1 }`, but is not checked.

@sum_tailrec shows a proc that writes the sum of the first `n` integers (and `acc`) to `d`.
#figure(
```
proc sum_tailrec (d : int) (n : int) (acc : int) =
    cut tst : bool
        call _eqz_ tst n
    read tst {
    | 'true(u) =>
        id d acc
    | 'false(u) => cut n1 : int
                       cut one : int
                           call _const_1 one
                       call _sub_ n1 n one
                   cut nxt : int
                       call _add_ nxt acc n
                   call sum_tailrec d n1 nxt
    }
```,
caption: [`sum_tailrec(n, acc)` = $sum(0..n) + "acc"$],
kind: "example",
supplement: "Example"
) <sum_tailrec>

== Compilation Stages

The compiler and runtime have several components. First, the compiler
does a simple pass over the Sax, generating a simple stack-based sequential IR
and doing a simple static analysis. Then, it does another pass over the stack-based IR
to generate WASM instructions. Finally, the compiler expects the WASM module to be optimized by
`wasm-opt`. It should not be strictly necessary, but there seem to be differences in how Wasmtime 
and `wasm-opt` validate modules, so output directly from the compiler often does not run in Wasmtime 
without using `wasm-opt` first.

= Implementation

The translation from Sax to WASM is guided by a few principles. First, the destination of the
current translated command is just the top of the stack. Thus, translating a metavariable writing
to destination `d` results in a sequence of WASM instructions that result in `d` on the top of the
stack.

The translation from the stack IR to WASM carefully tracks the stack and locals. In particular, it tries
to track the relationship between different variables, in order to accurately locate them in cases where a
stack value may represent both a variable and e.g. the left pi of a pair.
I believe this approach is convoluted and could be simplified by taking advantage of properties of the initial
translation from Sax to the stack IR. I designed it when I was trying to optimize exact stack and local layout.

Possible stack values are as follow:
- `Addr s`: an address bound to variable `s`
- `GcRef s`: a GC'd reference bound to variable `s`
- `InjTag s`: the tag of plus-type variable `s`
- `InjData s`: the injection of plus-type variable `s`
- `PairFst s`: the pi1 of pair-type variable `s`
- `PairSnd s`: the injection of pair-type variable `s`
- `Unit s`: a unit bound to variable `s`
    - These never actually materialize in WASM, and are instead used to pad with zero consts when needed
- `Int s`: an integer bound to variable `s`
    - Integers are passed by value

== Cuts and Locals

== Allocation

== Tail Calls

== Printing

== Optimizations

== Runtime

#lorem(480)

= Evaluation

#lorem(480)

= Related Work

#lorem(240)

= Conclusion

#lorem(120)
