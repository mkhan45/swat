# General structure

dest is the top of the stack

# TODO 3

1. make free follow refs?
    - I guess not, because the refs will be on the stack, and can be discarded later
2. negative types
    - Closures represented by { captures : addr list; func_idx : int }
    - records represented by { captures : addr list; record_inst_idx : int }
        - record_inst_idxs are static
    - in rust, let addr list be allocated by Vec
3. should free pairs read by switch
4. let functions return pairs, and only allocate when needed
5. make tailrecs actually loop?
    - idk how bad wasmtime is
6. reuse optimization
7. maybe try wasmer
    - could also try browser by writing the runtime stuff in JS or WASM

# TODO 2

1. Restructure get_addr, get_tag etc. 
    - GetAddr meta instr should take a list and ensure that the top of the stack is the list
    - get_addr, get_tag, etc. should look at the addr graph
    - get_addr, get_tag, etc. have three cases:
        1. Already on top (do nothing)
        2. Load from locals
        3. Load from memory, in which case both components should be loaded, maybe stored in locals
2. Switch refactor
    - Must detect when the variable it's switching on hasn't actually been allocated
    - Should free
3. Make free follow refs
    - Needs to accept a type
4. Avoid allocating variables that are read in the func

# TODO

1. Needed annotations for wasm_func_env:
    - Used out of cut order (to make locals)
    - Deref'd args
        - if an arg is deref'd/Read in all cases, make two locals for it instead of just the addr
        - conversely, if a cut variable is Read in all cases, we don't have to allocate it
2. negative polarity
3. I think we only have to allocate variables which are used as arguments.
